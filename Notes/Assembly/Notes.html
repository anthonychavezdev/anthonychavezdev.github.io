<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>x86 Assembly Notes</title>
<meta name="generator" content="Org Mode" />

      <link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
</head>
<body>
<header id="" class="status">

              <nav>
                  <a href="/">Home</a>
                  <a href="/contact.html">Contact me</a>
                  <a href="/Notes/">Notes</a>
                  <a href="/Projects/">Projects</a>
              </nav>
              <h1>x86 Assembly Notes</h1>
</header>
<main id="" class="content">

<div id="outline-container-org8846d9d" class="outline-2">
<h2 id="org8846d9d">Data Accessing methods</h2>
<div class="outline-text-2" id="text-org8846d9d">
</div>
<div id="outline-container-org26a62fd" class="outline-4">
<h4 id="org26a62fd">Immediate Mode</h4>
<div class="outline-text-4" id="text-org26a62fd">
<p>
The data to access is embedded in the instruction.
Example:
<code>movl $0 %eax</code> &lt;&#x2014; Move the literal number zero into register <code>eax</code>
</p>
</div>
</div>
<div id="outline-container-org636eeb9" class="outline-4">
<h4 id="org636eeb9">register addressing mode</h4>
<div class="outline-text-4" id="text-org636eeb9">
<p>
The instruction contains a register to access
</p>
</div>
</div>
<div id="outline-container-org2d998fa" class="outline-4">
<h4 id="org2d998fa">Memory Access Modes</h4>
<div class="outline-text-4" id="text-org2d998fa">
</div>
<ul class="org-ul">
<li><a id="org95ec359"></a>Direct Addressing Mode<br>
<div class="outline-text-5" id="text-org95ec359">
<p>
The instruction contains the memory address to access.
Example:
<code>movl 202 %eax</code> &lt;&#x2014; word starting at address 202 into register <code>eax</code>
</p>
</div>
</li>
<li><a id="org86bc1f6"></a>Indexed Addressing Mode<br>
<div class="outline-text-5" id="text-org86bc1f6">
<p>
Like <code>Direct Addressing Mode</code>, where an address is given, but an index register
is also specified to offset the address.
<b>On x86 processors, you can also specify a multiplier</b>
</p>
</div>
</li>
<li><a id="org1cc7a84"></a>Indirect Addressing Mode<br>
<div class="outline-text-5" id="text-org1cc7a84">
<p>
The instruction contains a register that holds a memory address to access.
Example:
<code>movl (%esp) %eax</code> &lt;&#x2014; Grabs the data at the memory address held in <code>esp</code>
</p>
</div>
</li>
<li><a id="org852d313"></a>Base Pointer Addressing Mode<br>
<div class="outline-text-5" id="text-org852d313">
<p>
Like <code>Indirect Addressing Mode</code>, but with an offset also given.
Example:
<code>movl 4(%esp) %eax</code> &lt;&#x2014; Adds 4 to the address in <code>esp</code> then fetches that data in memory.
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org233fdbe" class="outline-2">
<h2 id="org233fdbe">Calling Convention</h2>
<div class="outline-text-2" id="text-org233fdbe">
<p>
The way variables are stored, parameters are passed, and return values are transferred.
This varies from language to language.
One can use any calling convention when programming in Assembly.
The programmer can even come up with their own calling convention
</p>

<p>
<b>Linux uses the C calling conventions</b>
</p>
</div>
<div id="outline-container-orgb8154f6" class="outline-3">
<h3 id="orgb8154f6">interoperability</h3>
<div class="outline-text-3" id="text-orgb8154f6">
<p>
Other languages can have interoperability with assembly functions.
In order for this to work though, the language's calling convention
has to be used with the Assembly functions.
</p>
</div>
</div>
</div>

<div id="outline-container-org718e933" class="outline-2">
<h2 id="org718e933">C calling convention</h2>
<div class="outline-text-2" id="text-org718e933">
<p>
In the C calling convention, the <code>stack</code> is used heavily to hold function information.
The <code>stack</code> holds:
</p>
<ul class="org-ul">
<li>local variables</li>
<li>parameters</li>
<li>return address</li>
</ul>
</div>
<div id="outline-container-org5685698" class="outline-3">
<h3 id="org5685698">The Stack</h3>
<div class="outline-text-3" id="text-org5685698">
<p>
The stack lives at the very top addresses of memory, and grows down
Things can be pushed onto the stack with <code>pushl</code> and <code>popl</code>, where "l" is presumably for "long"
</p>
</div>
<div id="outline-container-orgd23f6a4" class="outline-4">
<h4 id="orgd23f6a4">Stack registers</h4>
<div class="outline-text-4" id="text-orgd23f6a4">
<ul class="org-ul">
<li><code>%esp</code>: holds a pointer to the top of the stack, starting at the highest address</li>
</ul>
</div>
</div>
<div id="outline-container-org39cce88" class="outline-4">
<h4 id="org39cce88">Pushing and popping</h4>
<div class="outline-text-4" id="text-org39cce88">
<p>
When we push onto the stack, <code>%esp</code> gets subtracted by 4 (stack grows down)
When we pop from the stack, <code>%esp</code> gets added by 4
</p>
</div>
</div>
<div id="outline-container-org35f7b34" class="outline-4">
<h4 id="org35f7b34">Calling functions</h4>
<div class="outline-text-4" id="text-org35f7b34">
<p>
Before executing a function, all the parameters are pushed onto the stack
in reverse order. 
Afterwards, The call instruction is issued which indicates which function
will be executed, the address of the next instruction is pushed onto the
stack (the return address), and the instruction pointer (<code>%eip</code>) is modified
to point to the start of the function.
</p>

<p>
Here's the Stack so far:
</p>

<table>


<colgroup>
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Stack</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Parameter #N</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Parameter 2</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Parameter 1</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Return Address  &lt;&#x2014; (%esp)</td>
</tr>
</tbody>
</table>

<p>
The function still has some work to do:
</p>
<ul class="org-ul">
<li>Save the current base pointer register (<code>%ebp</code>) onto the stack.
The <code>%ebp</code> register is used to access parameters and local variables.
We don't want to overwrite it if there was something previously there, so
it gets "backed up" somewhere else.</li>
<li><p>
Copy the stack pointer to <code>%ebp</code> (<code>movl %esp %ebp</code>)
This lets you use the base pointer as a sort of index to access the parameters.
Using the stack pointer isn't recommended, as the stack may change as things are
pushed and popped onto it (Like pushing arguments to other functions).
Copying the stack pointer at the start of every function makes it so you always know
where your function parameters are (As well as local variables).
</p>

<p>
The stack now looks like this:
</p></li>
</ul>

<table>


<colgroup>
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Stack</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Parameter #N    &lt;&#x2014; N*4+4(%ebp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Parameter 2     &lt;&#x2014; 12(%ebp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Parameter 1     &lt;&#x2014; 8(%ebp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Return Address  &lt;&#x2014; 4(%ebp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Old %ebp        &lt;&#x2014; (%esp) and (%ebp)</td>
</tr>
</tbody>
</table>


<p>
The function then reserves space on the stack for any local variables.
This is done by moving the stack pointer down a certain number of bytes.
Let's say we wanted to reserve 8 bytes for local variables.
We can do that by just <code>subl $8 %esp</code>.
This is done so we don't have to worry about clobbering them with pushes for
function calls.
<b><b>All of this is being done on the function's stack frame, so when it returns, all the variables will cease to exist</b></b>
</p>

<p>
The stack now looks like this:
</p>

<table>


<colgroup>
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Stack</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Parameter #N      &lt;&#x2014; N*4+4(%ebp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Parameter 2       &lt;&#x2014; 12(%ebp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Parameter 1       &lt;&#x2014; 8(%ebp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Return Address    &lt;&#x2014; 4(%ebp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Old %ebp          &lt;&#x2014; (%ebp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Local Variable 1  &lt;&#x2014; -4(%ebp)</td>
</tr>

<tr>
<td class="org-left">Local Variable 2  &lt;&#x2014; -8(%ebp) and (%esp)</td>
</tr>
</tbody>
</table>


<p>
All the data can be accessed using <code>base pointer addressing</code>, and using different
offsets from <code>%ebp</code>.
<code>%ebp</code> <b>exists for this exact purpose</b>
Other registers can be used for <code>base pointer addressing</code>, but x86 architecture makes using
<code>%ebp</code> really fast.
</p>
</div>
</div>
</div>
<div id="outline-container-org079385c" class="outline-3">
<h3 id="org079385c">returning from the function</h3>
<div class="outline-text-3" id="text-org079385c">
<p>
When a function is done executing, it has to:
</p>
<ol class="org-ol">
<li>Store the return value in <code>%eax</code>.</li>
<li>Restore the stack to what it looked like previously</li>
<li>Return control back to wherever it was called from.
This is done using the <code>ret</code> instruction, which pops
whatever was at the top of the stack, and sets the <code>%eip</code>
register to that value (the address of the instruction after <code>call</code>).</li>
</ol>
<p>
This all has to be done in that exact order for everything to work properly.
If the stack wasn't restored before <code>ret</code>, <code>ret</code> wouldn't function properly.
</p>

<p>
So to return, the following must be done:
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="font-weight: bold;">movl</span> <span style="font-weight: bold;">%ebp</span>, <span style="font-weight: bold; font-style: italic;">%esp</span> # Have the stack pointer (esp) point to where ebp is pointing
<span style="font-weight: bold;">popl</span> <span style="font-weight: bold;">%ebp</span>
<span style="font-weight: bold;">ret</span>
</pre>
</div>
<p>
You should consider all local variables inaccessible, as future stack pushes will overwrite them.
Let's look at this visually.
</p>

<p>
<code>movl %ebp, %esp</code>:
</p>

<table>


<colgroup>
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Stack</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Parameter #N      &lt;&#x2014; N*4+4(%ebp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Parameter 2       &lt;&#x2014; 12(%ebp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Parameter 1       &lt;&#x2014; 8(%ebp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Return Address    &lt;&#x2014; 4(%ebp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Old %ebp          &lt;&#x2014; (%ebp) and (%esp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Local Variable 1  &lt;&#x2014; -4(%ebp)</td>
</tr>

<tr>
<td class="org-left">Local Variable 2  &lt;&#x2014; -8(%ebp)</td>
</tr>
</tbody>
</table>


<p>
<code>popl %ebp</code>:
</p>

<table>


<colgroup>
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Stack</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Parameter #N</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Parameter 2</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Parameter 1</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Return Address    &lt;&#x2014; (%esp)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Local Variable 1</td>
</tr>

<tr>
<td class="org-left">Local Variable 2</td>
</tr>
</tbody>
</table>


<p>
Here, the <code>Old %ebp</code> value that was on the stack is popped, and placed back into <code>%ebp</code>.
And since we ran <code>popl</code>, <code>%esp</code> now points to the return address. We can finally execute the <code>ret</code>
instruction.
</p>

<p>
<b>Once out of the function, the parameters need to be popped off</b>
</p>
</div>
</div>
</div>
</main>
<footer id="" class="status">

              Created with: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.3 (<a href="https://orgmode.org">Org</a> mode 9.6.15)
</footer>
</body>
</html>
